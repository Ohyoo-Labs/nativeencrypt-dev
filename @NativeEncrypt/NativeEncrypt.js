import*as helpers from"./helpers.js";export const getDictionary=async function(r=""){try{if(r){const e=await fetch(r);if(!e.ok)throw new Error(`Error al cargar el diccionario: ${e.statusText}`);return await e.text()}return(await import("./dictionary.js")).dictionary}catch(r){throw new Error(`getDictionary Error: ${r.message}`)}};export const toBase64=async function(r=""){return r?btoa(r):r};export const fromBase64=async function(r=""){return r?atob(r):r};export const toUrl=async function(r=""){return r?encodeURIComponent(r):r};export const fromUrl=async function(r=""){return r?decodeURIComponent(r):r};export const toHex=async function(r=""){return r?helpers.stringToHex(r):r};export const fromHex=async function(r=""){return r?helpers.hexToString(r):r};export const base64ToHexConversion=async function(r=""){return r?helpers.base64ToHex(r):r};export const hexToBase64Conversion=async function(r=""){return r?helpers.hexToBase64(r):r};export const base64ToUrlConversion=async function(r=""){return r?helpers.base64ToUrl(r):r};export const urlToBase64Conversion=async function(r=""){return r?helpers.urlToBase64(r):r};export const hexToUrlConversion=async function(r=""){return r?helpers.hexToUrl(r):r};export const urlToHexConversion=async function(r=""){return r?helpers.urlToHex(r):r};export const generateSalt=function(r=16){if(r<=0)return"";const e="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";let t="";for(let n=0;n<r;n++)t+=e.charAt(Math.floor(Math.random()*e.length));return t};export const removeSalt=function(r,e=16){return"string"!=typeof r||r.length<e?"":r.slice(0,r.length-e)};export const caesarEncrypt=async function(r="",e=3){return r?r.replace(/[a-zA-Z]/g,(r=>{const t=r.charCodeAt(0),n=t+e,o=t>=65&&t<=90?65:97;return String.fromCharCode((n-o)%26+o)})):r};export const caesarDecrypt=async function(r="",e=3){return r?r.replace(/[a-zA-Z]/g,(r=>{const t=r.charCodeAt(0),n=t-e,o=t>=65&&t<=90?65:97;return String.fromCharCode((n-o+26)%26+o)})):r};const hashIndex=(r,e)=>(r+e)*e,unhashIndex=(r,e)=>r/e-e;export const dictionaryEncrypt=async function({text:r="",key:e="",salt:t=13,publickey:n=""}={}){try{if(!r)return r;e||(e=await getDictionary());let o=0;return n&&n.split("").forEach((r=>{const t=e.indexOf(r);if(!(t>-1))throw new Error(`Carácter no permitido en la clave: ${r}`);o+=parseInt(t,10)})),t=o?parseInt(o,10)*parseInt(t,10):parseInt(t,10),r.split("").map((r=>{const n=e.indexOf(r);return n>-1?hashIndex(n,t):r})).join(" ")}catch(r){throw new Error(`dictionaryEncrypt Error: ${r.message}`)}};export const dictionaryDecrypt=async function({text:r="",key:e="",salt:t=13,publickey:n=""}={}){if(!r)return r;e||(e=await getDictionary());let o=0;return n&&n.split("").forEach((r=>{const t=e.indexOf(r);if(!(t>-1))throw new Error(`Carácter no permitido en la clave: ${r}`);o+=parseInt(t,10)})),t=o?parseInt(o,10)*parseInt(t,10):parseInt(t,10),r.split(" ").map((r=>{const n=parseInt(r,10),o=unhashIndex(n,t);return!isNaN(o)&&o>=0&&o<e.length?e[Math.round(o)]:r})).join("")};export const generateKey=async(r="AES-GCM")=>{switch(r){case"AES-CBC":case"AES-GCM":case"AES-CTR":return await crypto.subtle.generateKey({name:r,length:256},!0,["encrypt","decrypt"]);case"RSA-OAEP":return await generateRSAKeyPair();default:throw new Error(`Algoritmo no soportado: ${r}`)}};export const generateAesGcmKey=async(r,e="SHA-256",t=256)=>{try{const n=(new TextEncoder).encode(r),o=await crypto.subtle.digest(e,n),a=new Uint8Array(o),c=t/8;return await crypto.subtle.importKey("raw",a.slice(0,c),"AES-GCM",!0,["encrypt","decrypt"])}catch(r){throw console.error(`Error al generar la clave AES-GCM desde la semilla con ${e} y longitud ${t}:`,r),new Error(`generateAesGcmKeyFromSeed Error: ${r.message}`)}};export const exportKey=async r=>{try{if(r.publicKey&&r.privateKey){const e=await crypto.subtle.exportKey("spki",r.publicKey),t=await crypto.subtle.exportKey("pkcs8",r.privateKey);return{publicKey:Array.from(new Uint8Array(e)),privateKey:Array.from(new Uint8Array(t))}}if(r.algorithm&&"RSA-OAEP"===r.algorithm.name){const e=await crypto.subtle.exportKey("spki",r);return Array.from(new Uint8Array(e))}{const e=await crypto.subtle.exportKey("raw",r);return Array.from(new Uint8Array(e))}}catch(r){throw new Error(`exportKey Error: ${r.message}`)}};export const importKey=async(r,e="AES-GCM",t="SHA-256")=>{switch(e){case"AES-CBC":case"AES-GCM":case"AES-CTR":return await crypto.subtle.importKey("raw",new Uint8Array(r),{name:e,length:256},!0,["encrypt","decrypt"]);case"RSA-OAEP":if(r.publicKey&&r.privateKey){return{publicKey:await crypto.subtle.importKey("spki",new Uint8Array(r.publicKey),{name:"RSA-OAEP",hash:t},!0,["encrypt"]),privateKey:await crypto.subtle.importKey("pkcs8",new Uint8Array(r.privateKey),{name:"RSA-OAEP",hash:t},!0,["decrypt"])}}throw new Error("RSA-OAEP requiere tanto la clave pública como la privada.");default:throw new Error(`Algoritmo no soportado: ${e}`)}};const generateIV=(r="AES-GCM")=>{let e;switch(r){case"AES-CBC":case"AES-CTR":e=16;break;case"AES-GCM":e=12;break;default:throw new Error(`Algoritmo no soportado para IV: ${r}`)}return crypto.getRandomValues(new Uint8Array(e))},generateRSAKeyPair=async(r="SHA-256",e=2048)=>{try{return await crypto.subtle.generateKey({name:"RSA-OAEP",modulusLength:e,publicExponent:new Uint8Array([1,0,1]),hash:r},!0,["encrypt","decrypt"])}catch(r){throw new Error(`generateRSAKeyPair Error: ${r.message}`)}};export const encrypt=async({text:r=null,algorithm:e="AES-GCM",key:t=null,options:n=null}={})=>{try{let n,o;t||(t=await generateKey(e)),"RSA-OAEP"===e?o={name:e}:(n=generateIV(e),o="AES-CTR"===e?{name:e,counter:n,length:128}:{name:e,iv:n});const a=(new TextEncoder).encode(r),c=await crypto.subtle.encrypt(o,t.publicKey||t,a);let s=null;if("RSA-OAEP"!==e){const r=await crypto.subtle.exportKey("raw",t).catch((()=>null));r&&(s=Array.from(new Uint8Array(r)))}return{key:s,iv:n?Array.from(n):null,data:Array.from(new Uint8Array(c)),algorithm:e}}catch(r){throw new Error(`encrypt Error: ${r.message}`)}};export const decrypt=async({encrypted:r=null,algorithm:e="AES-GCM",key:t=null,options:n=null}={})=>{try{if(!t&&r.key)t=await importKey(r.key,e,n?.sha??"SHA-256");else{if("RSA-OAEP"===e&&!t)throw new Error("Clave requerida para descifrar RSA-OAEP.");if(!t)throw new Error("Clave requerida para descifrar.")}let o,a;if("RSA-OAEP"===e)o={name:e};else{const t=new Uint8Array(r.iv);o="AES-CTR"===e?{name:e,counter:t,length:128}:{name:e,iv:t}}a="RSA-OAEP"===e?await crypto.subtle.decrypt(o,t.privateKey,new Uint8Array(r.data)):await crypto.subtle.decrypt(o,t,new Uint8Array(r.data));return(new TextDecoder).decode(a)}catch(r){throw new Error(`decrypt Error: ${r.message}`)}};