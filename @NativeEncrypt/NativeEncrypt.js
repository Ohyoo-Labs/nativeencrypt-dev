import*as helpers from"./helpers.js";export const getDictionary=async function(r=""){try{if(r){const e=await fetch(r);if(!e.ok)throw new Error(`Error al cargar el diccionario: ${e.statusText}`);return await e.text()}return(await import("./dictionary.js")).dictionary}catch(r){throw new Error(`getDictionary Error: ${r.message}`)}};export const toBase64=async function(r=""){return r?btoa(r):r};export const fromBase64=async function(r=""){return r?atob(r):r};export const toUrl=async function(r=""){return r?encodeURIComponent(r):r};export const fromUrl=async function(r=""){return r?decodeURIComponent(r):r};export const toHex=async function(r=""){return r?helpers.stringToHex(r):r};export const fromHex=async function(r=""){return r?helpers.hexToString(r):r};export const base64ToHexConversion=async function(r=""){return r?helpers.base64ToHex(r):r};export const hexToBase64Conversion=async function(r=""){return r?helpers.hexToBase64(r):r};export const base64ToUrlConversion=async function(r=""){return r?helpers.base64ToUrl(r):r};export const urlToBase64Conversion=async function(r=""){return r?helpers.urlToBase64(r):r};export const hexToUrlConversion=async function(r=""){return r?helpers.hexToUrl(r):r};export const urlToHexConversion=async function(r=""){return r?helpers.urlToHex(r):r};export const caesarEncrypt=async function(r="",e=3){return r?r.replace(/[a-zA-Z]/g,(r=>{const t=r.charCodeAt(0),n=t+e,a=t>=65&&t<=90?65:97;return String.fromCharCode((n-a)%26+a)})):r};export const caesarDecrypt=async function(r="",e=3){return r?r.replace(/[a-zA-Z]/g,(r=>{const t=r.charCodeAt(0),n=t-e,a=t>=65&&t<=90?65:97;return String.fromCharCode((n-a+26)%26+a)})):r};const hashIndex=(r,e)=>(r+e)*e,unhashIndex=(r,e)=>r/e-e;export const dictionaryEncrypt=async function({text:r="",key:e="",salt:t=13,publickey:n=""}={}){try{if(!r)return r;e||(e=await getDictionary());let a=0;return n&&n.split("").forEach((r=>{const t=e.indexOf(r);if(!(t>-1))throw new Error(`Carácter no permitido en la clave: ${r}`);a+=parseInt(t,10)})),t=a?parseInt(a,10)*parseInt(t,10):parseInt(t,10),r.split("").map((r=>{const n=e.indexOf(r);return n>-1?hashIndex(n,t):r})).join(" ")}catch(r){throw new Error(`dictionaryEncrypt Error: ${r.message}`)}};export const dictionaryDecrypt=async function({text:r="",key:e="",salt:t=13,publickey:n=""}={}){if(!r)return r;e||(e=await getDictionary());let a=0;return n&&n.split("").forEach((r=>{const t=e.indexOf(r);if(!(t>-1))throw new Error(`Carácter no permitido en la clave: ${r}`);a+=parseInt(t,10)})),t=a?parseInt(a,10)*parseInt(t,10):parseInt(t,10),r.split(" ").map((r=>{const n=parseInt(r,10),a=unhashIndex(n,t);return!isNaN(a)&&a>=0&&a<e.length?e[Math.round(a)]:r})).join("")};export const generateKey=async(r="AES-GCM")=>{switch(r){case"AES-CBC":case"AES-GCM":case"AES-CTR":return await crypto.subtle.generateKey({name:r,length:256},!0,["encrypt","decrypt"]);case"RSA-OAEP":return await generateRSAKeyPair();default:throw new Error(`Algoritmo no soportado: ${r}`)}};export const exportKey=async r=>{try{if(r.publicKey&&r.privateKey){const e=await crypto.subtle.exportKey("spki",r.publicKey),t=await crypto.subtle.exportKey("pkcs8",r.privateKey);return{publicKey:Array.from(new Uint8Array(e)),privateKey:Array.from(new Uint8Array(t))}}if(r.algorithm&&"RSA-OAEP"===r.algorithm.name){const e=await crypto.subtle.exportKey("spki",r);return Array.from(new Uint8Array(e))}{const e=await crypto.subtle.exportKey("raw",r);return Array.from(new Uint8Array(e))}}catch(r){throw new Error(`exportKey Error: ${r.message}`)}};export const importKey=async(r,e="AES-GCM",t="SHA-256")=>{switch(e){case"AES-CBC":case"AES-GCM":case"AES-CTR":return await crypto.subtle.importKey("raw",new Uint8Array(r),{name:e,length:256},!0,["encrypt","decrypt"]);case"RSA-OAEP":if(r.publicKey&&r.privateKey){return{publicKey:await crypto.subtle.importKey("spki",new Uint8Array(r.publicKey),{name:"RSA-OAEP",hash:t},!0,["encrypt"]),privateKey:await crypto.subtle.importKey("pkcs8",new Uint8Array(r.privateKey),{name:"RSA-OAEP",hash:t},!0,["decrypt"])}}throw new Error("RSA-OAEP requiere tanto la clave pública como la privada.");default:throw new Error(`Algoritmo no soportado: ${e}`)}};const generateIV=(r="AES-GCM")=>{let e;switch(r){case"AES-CBC":case"AES-CTR":e=16;break;case"AES-GCM":e=12;break;default:throw new Error(`Algoritmo no soportado para IV: ${r}`)}return crypto.getRandomValues(new Uint8Array(e))},generateRSAKeyPair=async(r="SHA-256",e=2048)=>{try{return await crypto.subtle.generateKey({name:"RSA-OAEP",modulusLength:e,publicExponent:new Uint8Array([1,0,1]),hash:r},!0,["encrypt","decrypt"])}catch(r){throw new Error(`generateRSAKeyPair Error: ${r.message}`)}};export const encrypt=async(r,e="AES-GCM",t=null,n={})=>{try{let n,a;t||(t=await generateKey(e)),"RSA-OAEP"===e?a={name:e}:(n=generateIV(e),a="AES-CTR"===e?{name:e,counter:n,length:128}:{name:e,iv:n});const o=(new TextEncoder).encode(r),c=await crypto.subtle.encrypt(a,t.publicKey||t,o);let s=null;if("RSA-OAEP"!==e){const r=await crypto.subtle.exportKey("raw",t).catch((()=>null));r&&(s=Array.from(new Uint8Array(r)))}return{key:s,iv:n?Array.from(n):null,data:Array.from(new Uint8Array(c)),algorithm:e}}catch(r){throw new Error(`encrypt Error: ${r.message}`)}};export const decrypt=async(r,e="AES-GCM",t=null,n={})=>{try{if(!t&&r.key)t=await importKey(r.key,e,n.sha);else{if("RSA-OAEP"===e&&!t)throw new Error("Clave requerida para descifrar RSA-OAEP.");if(!t)throw new Error("Clave requerida para descifrar.")}let a,o;if("RSA-OAEP"===e)a={name:e};else{const t=new Uint8Array(r.iv);a="AES-CTR"===e?{name:e,counter:t,length:128}:{name:e,iv:t}}o="RSA-OAEP"===e?await crypto.subtle.decrypt(a,t.privateKey,new Uint8Array(r.data)):await crypto.subtle.decrypt(a,t,new Uint8Array(r.data));return(new TextDecoder).decode(o)}catch(r){throw new Error(`decrypt Error: ${r.message}`)}};